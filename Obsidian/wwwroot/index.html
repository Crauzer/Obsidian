<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Obsidian</title>
    <base href="/" />
    <link href="css/app.css" rel="stylesheet" />
    <link href="Obsidian.styles.css" rel="stylesheet">
    <link href="_content/MudBlazor/MudBlazor.min.css" rel="stylesheet" />
    <link href="_content/CodeBeam.MudExtensions/MudExtensions.min.css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
    <script src="photino.js"></script>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylon.gridMaterial.min.js"></script>
    <!-- links to the latest version of the glTF serializer -->
    <script src="https://preview.babylonjs.com/serializers/babylonjs.glTF2Serializer.js"></script>
    <!-- links to the latest version of the minified glTF serializer -->
    <script src="https://preview.babylonjs.com/serializers/babylonjs.glTF2Serializer.min.js"></script>

</head>
<body>
    <app>Loading...</app>

    <div id="blazor-error-ui">
        An unhandled error has occurred.
        <a href="" class="reload">Reload</a>
        <a class="dismiss">ðŸ—™</a>
    </div>

    <script src="_framework/blazor.webview.js"></script>
    <script src="_content/MudBlazor/MudBlazor.min.js"></script>
    <script src="_content/CodeBeam.MudExtensions/MudExtensions.js"></script>

    <script>
        const Photino = PhotinoAPI.Photino;

        async function useCmd(command) {
            await Photino.os.cmd(command);
        }

        window.setImage = async (imageElementId, imageStream) => {
            const url = await createImageBlobFromStream(imageStream);
            const image = document.getElementById(imageElementId);
            image.onload = () => {
                URL.revokeObjectURL(url);
            }
            image.src = url;
        }

        async function createImageBlobFromStream(imageStream) {
            const arrayBuffer = await imageStream.arrayBuffer();
            const blob = new Blob([arrayBuffer]);

            return URL.createObjectURL(blob);
        }

        const babylonScenes = new Map();
        const babylonEngines = new Map();

        window.initBabylonCanvas = (canvasId) => {
            const canvas = document.getElementById(canvasId); // Get the canvas element

            const engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine
            babylonEngines.set(canvasId, engine);

            engine.setHardwareScalingLevel(1 / window.devicePixelRatio);

            const createScene = function () {
                // This creates a basic Babylon Scene object (non-mesh)
                const scene = new BABYLON.Scene(engine);

                // Parameters: name, alpha, beta, radius, target position, scene
                const camera = new BABYLON.ArcRotateCamera("Camera", Math.PI / 3, Math.PI / 3, 1000, BABYLON.Vector3.Zero(), scene);

                camera.setTarget(BABYLON.Vector3.Zero());
                camera.zoomToMouseLocation = true;
                camera.wheelDeltaPercentage = 0.01;
                camera.panningSensibility = 50;

                // This attaches the camera to the canvas
                camera.attachControl(canvas, true);

                // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
                const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

                // Our built-in 'ground' shape.
                const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 1000, height: 1000 }, scene, false);
                ground.material = new BABYLON.GridMaterial("groundMat");
                ground.material.majorUnitFrequency = 5;
                ground.material.minorUnitVisibility = 0.5;
                ground.material.gridRatio = 2;
                ground.material.opacity = 0.99;
                ground.material.useMaxLine = true;

                return scene;
            };

            const scene = createScene();
            babylonScenes.set(canvasId, scene);

            scene.debugLayer.show({
                embedMode: true
            });

            const fpsElement = document.getElementById(`${canvasId}_fps`);

            // Register a render loop to repeatedly render the scene
            engine.runRenderLoop(function () {
                fpsElement.innerText = "FPS: " + engine.getFps().toFixed();
                scene.render();
            });

            // Watch for browser/canvas resize events
            window.addEventListener("resize", function () {
                engine.resize();
            });
        }

        function destroyBabylonCanvas(canvasId) {
            const scene = babylonScenes.get(canvasId);
            if (scene) {
                scene.dispose();
                babylonScenes.delete(canvasId);
            }

            const engine = babylonEngines.get(canvasId);
            if (engine) {
                engine.dispose();
                babylonEngines.delete(canvasId);
            }
        }

        window.resizeBabylonEngine = (canvasId) => {
            babylonEngines.get(canvasId).resize();
        }

        window.renderSkinnedMesh = (canvasId, joints, primitives, indices, positions, normals, uvs, weightIds, weights, textures) => {
            console.info(textures);
            const scene = babylonScenes.get(canvasId);

            const mesh = new BABYLON.Mesh("skinned_mesh", scene);
            const meshMultiMaterial = new BABYLON.MultiMaterial("multi", scene);

            // Create skeleton
            const skeleton = new BABYLON.Skeleton("skeleton", "skinned_mesh_skeleton");
            createBones(skeleton, joints);
            mesh.skeleton = skeleton;

            // Create materials for each primitive
            primitives.forEach(primitive => {
                const material = new BABYLON.StandardMaterial(primitive.material, scene);

                material.twoSidedLighting = true;
                material.backFaceCulling = false;

                //material.diffuseColor = new BABYLON.Color3(Math.random(), Math.random(), Math.random());
                material.diffuseTexture = new BABYLON.Texture(textures[primitive.material], scene);
                material.diffuseTexture.vScale = -1;

                material.emissiveColor = new BABYLON.Color3(1, 1, 1);

                meshMultiMaterial.subMaterials.push(material);
            });

            // Apply material
            mesh.material = meshMultiMaterial;

            // Apply vertex data
            const vertexData = new BABYLON.VertexData();
            vertexData.indices = indices;
            vertexData.positions = positions;
            vertexData.normals = normals;
            vertexData.uvs = uvs;
            vertexData.matricesIndices = weightIds;
            vertexData.matricesWeights = weights;

            vertexData.applyToMesh(mesh);

            // Create submeshes
            mesh.subMeshes = [];
            primitives.forEach((primitive, i) => {
                new BABYLON.SubMesh(i, primitive.startIndex, primitive.vertexCount, primitive.startIndex, primitive.indexCount, mesh);
            });

            scene.debugLayer.show({
                embedMode: true
            });
        }

        function createBones(skeleton, joints) {
            createdBones = [];

            joints.forEach(joint => {
                createBone(skeleton, joint, joints, createdBones);
            });
        }

        function createBone(skeleton, joint, joints, createdBones) {
            const existingBone = createdBones.find(x => x.name === joint.name);
            if (existingBone) {
                return existingBone;
            }

            if (joint.parentId === -1) {
                const bone = new BABYLON.Bone(
                    joint.name,
                    skeleton,
                    null,
                    BABYLON.Matrix.FromArray(joint.localTransform),
                    BABYLON.Matrix.FromArray(joint.inverseBindTransform),
                    null,
                    joint.id
                );

                createdBones.push(bone);
                return bone;
            } else {
                const parentJoint = joints[joint.parentId];
                let parentBone = createdBones.find(x => x.name === parentJoint.name);
                if (!parentBone) {
                    parentBone = createBone(skeleton, parentJoint, joints, createdBones);
                }

                const bone = new BABYLON.Bone(
                    joint.name,
                    skeleton,
                    parentBone,
                    BABYLON.Matrix.FromArray(joint.localTransform),
                    BABYLON.Matrix.FromArray(joint.inverseBindTransform),
                    null,
                    joint.id
                );

                createdBones.push(bone);
                return bone;
            }
        }
    </script>
</body>
</html>